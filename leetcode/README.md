# LeetCode Problem Types

## 10 Common Problem Categories

1. **Hashmaps / Hash Tables**
   - **Strategy**: Use hashmap to store key-value pairs for O(1) lookups. Count frequencies, track occurrences, or map relationships.
   - **Common Problems**: Two Sum, Valid Anagram, Group Anagrams, First Unique Character, Intersection of Two Arrays

2. **Two Pointers**
   - **Strategy**: Use two pointers moving from opposite ends or same direction to reduce time complexity from O(nÂ²) to O(n).
   - **Common Problems**: Valid Palindrome, Container With Most Water, 3Sum, Trapping Rain Water, Move Zeroes

3. **Sliding Window**
   - **Strategy**: Maintain a window of elements and slide it through the array/string. Use hashmap to track window contents.
   - **Common Problems**: Longest Substring Without Repeating Characters, Minimum Window Substring, Maximum Average Subarray, Permutation in String

4. **Binary Search**
   - **Strategy**: Eliminate half of search space at each step. Works on sorted arrays or when you can determine which half contains the answer.
   - **Common Problems**: Binary Search, Search in Rotated Sorted Array, Find Peak Element, Search Insert Position, Sqrt(x)

5. **Stack / Queue**
   - **Strategy**: Use LIFO (stack) or FIFO (queue) to process elements in order. Track previous elements or process level by level.
   - **Common Problems**: Valid Parentheses, Daily Temperatures, Next Greater Element, Implement Queue using Stacks, Level Order Traversal

6. **Trees (Binary Trees, BST)**
   - **Strategy**: Recursive or iterative traversal (DFS/BFS). Use recursion for tree structure. Leverage BST properties for efficient search.
   - **Common Problems**: Maximum Depth of Binary Tree, Validate Binary Search Tree, Invert Binary Tree, Lowest Common Ancestor, Path Sum

7. **Graphs (DFS/BFS)**
   - **Strategy**: Traverse vertices and edges. DFS for paths/connected components. BFS for shortest paths or level-order processing.
   - **Common Problems**: Number of Islands, Clone Graph, Course Schedule, Word Ladder, Network Delay Time

8. **Greedy Algorithms**
   - **Strategy**: Make locally optimal choice at each step to reach global optimum. Often combined with sorting or priority queues.
   - **Common Problems**: Jump Game, Merge Intervals, Non-overlapping Intervals, Best Time to Buy and Sell Stock, Gas Station

9. **Backtracking**
   - **Strategy**: Build solution incrementally, backtrack when constraint violated. Try all possibilities, undo choices that don't work.
   - **Common Problems**: N-Queens, Generate Parentheses, Combination Sum, Letter Combinations of Phone Number, Word Search

10. **Dynamic Programming**
    - **Strategy**: Break problem into subproblems, store results to avoid recomputation. Identify base cases and recurrence relation.
    - **Common Problems**: Climbing Stairs, House Robber, Longest Increasing Subsequence, Coin Change, Edit Distance

